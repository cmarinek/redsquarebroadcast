import { useEffect, useRef } from 'react';
import { postTVProfilingBatch } from '../utils/metricsClient';

interface Sample {
  ts: number;
  fps?: number;
  event?: string;
  data?: any;
}

interface UseTVProfilingOptions {
  enabled?: boolean;
  sampleIntervalMs?: number;
  batchSize?: number;
  postIntervalMs?: number;
}

export function useTVProfiling(options: UseTVProfilingOptions = {}) {
  const opts = {
    enabled: true,
    sampleIntervalMs: 1000,
    batchSize: 50,
    postIntervalMs: 5000,
    ...options,
  };

  const runningRef = useRef(false);
  const rafRef = useRef<number | null>(null);
  const lastFrameRef = useRef<number | null>(null);
  const accumRef = useRef<Sample[]>([]);
  const lastPostRef = useRef<number>(Date.now());

  useEffect(() => {
    if (!opts.enabled) return;

    runningRef.current = true;
    lastFrameRef.current = null;

    const tick = (now: number) => {
      if (!runningRef.current) return;
      if (lastFrameRef.current != null) {
        const dt = now - lastFrameRef.current;
        const fps = dt > 0 ? Math.round(1000 / dt) : undefined;
        accumRef.current.push({ ts: Date.now(), fps });
      }
      lastFrameRef.current = now;
      rafRef.current = requestAnimationFrame(tick);

      const nowTs = Date.now();
      if (accumRef.current.length >= opts.batchSize || nowTs - lastPostRef.current >= opts.postIntervalMs) {
        const toSend = accumRef.current.splice(0, accumRef.current.length);
        lastPostRef.current = nowTs;
        if (toSend.length > 0) {
          postTVProfilingBatch({ samples: toSend }).catch((err) => {
            // eslint-disable-next-line no-console
            console.warn('useTVProfiling post failed', err);
          });
        }
      }
    };

    rafRef.current = requestAnimationFrame(tick);

    const navLatencyHandler = (e: Event) => {
      const ce = e as CustomEvent;
      const detail = ce.detail || {};
      const sample: Sample = {
        ts: Date.now(),
        event: 'nav-latency',
        data: detail,
      };
      accumRef.current.push(sample);
    };
    window.addEventListener('nav-latency', navLatencyHandler as EventListener);

    return () => {
      runningRef.current = false;
      if (rafRef.current != null) {
        cancelAnimationFrame(rafRef.current);
      }
      window.removeEventListener('nav-latency', navLatencyHandler as EventListener);

      const remaining = accumRef.current.splice(0, accumRef.current.length);
      if (remaining.length > 0) {
        postTVProfilingBatch({ samples: remaining }).catch(() => {
          // ignore
        });
      }
    };
  }, [opts.enabled, opts.sampleIntervalMs, opts.batchSize, opts.postIntervalMs]);
}

name: Build RedSquare Screens (Windows)

on:
  repository_dispatch:
    types: [trigger-screens-windows-build]
  workflow_dispatch:
    inputs:
      build_id:
        description: 'ID of the build record in the database'
        required: true
      version:
        description: 'Version for this build'
        required: true
        default: '1.0.0-manual'

env:
  VITE_SUPABASE_URL: ${{ secrets.VITE_SUPABASE_URL }}
  VITE_SUPABASE_ANON_KEY: ${{ secrets.VITE_SUPABASE_ANON_KEY }}
  VITE_SUPABASE_PROJECT_ID: ${{ secrets.VITE_SUPABASE_PROJECT_ID }}
  VITE_MAPBOX_PUBLIC_TOKEN: ${{ secrets.VITE_MAPBOX_PUBLIC_TOKEN }}
  VITE_STRIPE_PUBLISHABLE_KEY: ${{ secrets.VITE_STRIPE_PUBLISHABLE_KEY }}
  SUPABASE_URL: ${{ secrets.VITE_SUPABASE_URL }}
  SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
  MAPBOX_PUBLIC_TOKEN: ${{ secrets.VITE_MAPBOX_PUBLIC_TOKEN }}
  STRIPE_SECRET_KEY: ${{ secrets.STRIPE_SECRET_KEY }}
  RESEND_API_KEY: ${{ secrets.RESEND_API_KEY }}
  HUGGING_FACE_ACCESS_TOKEN: ${{ secrets.HUGGING_FACE_ACCESS_TOKEN }}
  GH_ACCESS_TOKEN: ${{ secrets.GH_ACCESS_TOKEN }}
  GH_REPO_OWNER: ${{ secrets.GH_REPO_OWNER }}
  GH_REPO_NAME: ${{ secrets.GH_REPO_NAME }}

jobs:
  build-screens-windows:
    runs-on: windows-latest
    permissions:
      contents: write
      actions: write
    steps:
      - name: Get Build Info from Dispatch
        id: build_info
        run: |
          if ("${{ github.event.client_payload.build_id }}" -ne "") {
            echo "build_id=${{ github.event.client_payload.build_id }}" >> $env:GITHUB_OUTPUT
            echo "version=${{ github.event.client_payload.version }}" >> $env:GITHUB_OUTPUT
          } else {
            echo "build_id=${{ github.event.inputs.build_id }}" >> $env:GITHUB_OUTPUT
            echo "version=${{ github.event.inputs.version }}" >> $env:GITHUB_OUTPUT
          }
        shell: pwsh

      - name: Update Build Status to 'In Progress'
        run: |
          $supabaseUrl = "${{ secrets.SUPABASE_URL }}"
          if ([string]::IsNullOrEmpty($supabaseUrl)) {
            Write-Error "SUPABASE_URL secret not set"
            exit 1
          }
          
          $body = @{
            build_id = "${{ steps.build_info.outputs.build_id }}";
            status = "in_progress";
            logs_url = "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}";
            commit_hash = "${{ github.sha }}";
          } | ConvertTo-Json -Compress

          Invoke-RestMethod -Uri "${supabaseUrl}/functions/v1/update-build-status" `
            -Method POST `
            -Headers @{
              "Authorization" = "Bearer ${{ secrets.GH_ACTION_SECRET }}";
              "Content-Type" = "application/json";
            } `
            -Body $body
        shell: pwsh

      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Dependencies
        run: npm install

      - name: Build Web App
        run: npm run build
        env:
          VITE_BUILD_TARGET: electron
          VITE_APP_TYPE: screens

      - name: Build Desktop App
        run: |
          Write-Host "Building Electron app with optimizations..."
          
          # Validate and build using our script
          node scripts/electron-build.js validate
          node scripts/electron-build.js prepare
          node scripts/electron-build.js build windows
          
          try {
            Write-Host "Build command completed. Checking output..."
            
            # List all files in dist-electron directory for debugging
            if (Test-Path "dist-electron") {
              Write-Host "Contents of dist-electron directory:"
              Get-ChildItem -Path "dist-electron" -Recurse | ForEach-Object {
                Write-Host "  $($_.FullName) ($(if($_.PSIsContainer){'Directory'}else{[math]::Round($_.Length/1MB,2).ToString() + ' MB'}))"
              }
            } else {
              Write-Error "dist-electron directory was not created by build process"
              exit 1
            }
            
            # Check if build was successful
            $file = Get-ChildItem -Path dist-electron -Filter "*.exe" | Select-Object -First 1
            if (-not $file) {
              Write-Error "No executable file found in dist-electron directory. Build may have failed."
              Write-Host "Available files:"
              Get-ChildItem -Path dist-electron -File | ForEach-Object { Write-Host "  $($_.Name)" }
              exit 1
            }
            
            # Check file size (500MB limit)
            $fileSizeMB = [math]::Round($file.Length / 1MB, 2)
            Write-Host "Built executable: $($file.Name) - Size: $fileSizeMB MB"
            
            if ($file.Length -gt 500000000) {
              Write-Warning "File size ($fileSizeMB MB) exceeds 500MB limit. Consider optimizing the build."
            }
          }
          catch {
            Write-Error "Build failed with error: $($_.Exception.Message)"
            Write-Host "Stack trace:"
            Write-Host $_.ScriptStackTrace
            exit 1
          }
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }} # electron-builder may need this to download binaries
        shell: pwsh

      - name: Create and Upload Artifact Zip
        id: upload_artifact
        run: |
          $file = Get-ChildItem -Path dist-electron -Filter "*.exe" | Select-Object -First 1
          if (-not $file) {
            Write-Error "No .exe file found in dist-electron directory"
            exit 1
          }
          
          $fileName = $file.Name
          $filePath = $file.FullName
          $fileSizeMB = [math]::Round($file.Length / 1MB, 2)
          $fileSizeBytes = $file.Length
          
           Write-Host "Original file: $fileName (${fileSizeMB}MB)"
           Write-Host "File size in bytes: $fileSizeBytes"
          
          # Create 7z archive for better compression
          $zipName = "RedSquare-Screens-Windows-v${{ steps.build_info.outputs.version }}.7z"
          $zipPath = Join-Path $env:TEMP $zipName
          
          Write-Host "Creating 7z archive: $zipName"
          
          # Install 7-Zip if not available
          if (-not (Get-Command "7z" -ErrorAction SilentlyContinue)) {
            Write-Host "Installing 7-Zip..."
            choco install 7zip -y
            $env:PATH += ";C:\Program Files\7-Zip"
          }
          
          # Create 7z archive with maximum compression
          & 7z a -t7z -m0=lzma2 -mx=9 -mfb=64 -md=32m -ms=on "$zipPath" "$filePath"
          
          # Check 7z file size
          $zipFile = Get-Item $zipPath
          $zipSizeMB = [math]::Round($zipFile.Length / 1MB, 2)
          $compressionRatio = [math]::Round((1 - $zipFile.Length / $file.Length) * 100, 1)
           Write-Host "7z archive created: $zipName (${zipSizeMB}MB) - Compression ratio: ${compressionRatio}%"
          
           # Instead of uploading to Supabase (size limits), use GitHub Releases
           Write-Host "Using GitHub Releases for large Windows binaries..."
           
           # Create a unique tag for this build  
           $tag = "screens-windows-v${{ steps.build_info.outputs.version }}"
           $releaseName = "RedSquare Screens Windows v${{ steps.build_info.outputs.version }}"
           
           # Create GitHub Release with proper error handling
           $releaseBody = @{
             tag_name = $tag
             target_commitish = "${{ github.sha }}"
             name = $releaseName
             body = "Automated build of RedSquare Screens for Windows`n`nCommit: ${{ github.sha }}`nFile size: ${zipSizeMB}MB"
             draft = $false
             prerelease = $true
           } | ConvertTo-Json -Depth 10
           
           try {
             $releaseResponse = Invoke-RestMethod -Uri "https://api.github.com/repos/${{ github.repository }}/releases" `
               -Method POST `
               -Headers @{
                 "Authorization" = "Bearer ${{ secrets.GITHUB_TOKEN }}"
                 "Accept" = "application/vnd.github.v3+json"
                 "Content-Type" = "application/json"
                 "User-Agent" = "GitHub-Actions"
               } `
               -Body $releaseBody `
               -StatusCodeVariable httpStatus
             
             Write-Host "GitHub Release API Status: $httpStatus"
             Write-Host "Created GitHub Release: $($releaseResponse.html_url)"
           }
           catch {
             Write-Error "Failed to create GitHub release: $($_.Exception.Message)"
             Write-Error "Response: $($_.Exception.Response | ConvertTo-Json -Depth 3)"
             exit 1
           }
           
           # Upload asset to the release
           $assetName = "RedSquare-Screens-Windows-v${{ steps.build_info.outputs.version }}.7z"
           $uploadUrl = $releaseResponse.upload_url -replace '\{.*\}', "?name=$assetName&label=Windows%20Desktop%20App"
           
           Write-Host "Upload URL: $uploadUrl"
           Write-Host "Uploading asset: $assetName"
           
           try {
             $uploadResponse = Invoke-RestMethod -Uri $uploadUrl `
               -Method POST `
               -Headers @{
                 "Authorization" = "Bearer ${{ secrets.GITHUB_TOKEN }}"
                 "Content-Type" = "application/x-7z-compressed"
                 "User-Agent" = "GitHub-Actions"
               } `
               -InFile $zipPath `
               -StatusCodeVariable uploadStatus
             
             Write-Host "Upload API Status: $uploadStatus"
             $downloadUrl = $uploadResponse.browser_download_url
             
             if ([string]::IsNullOrEmpty($downloadUrl)) {
               Write-Error "Failed to get download URL from upload response"
               exit 1
             }
             
             Write-Host "Asset uploaded successfully: $downloadUrl"
           }
           catch {
             Write-Error "Failed to upload asset: $($_.Exception.Message)"
             Write-Error "Response: $($_.Exception.Response | ConvertTo-Json -Depth 3)"
             exit 1
           }
           
           echo "artifact_url=$downloadUrl" >> $env:GITHUB_OUTPUT
           
           # Clean up temp files
           if (Test-Path $zipPath) {
             Remove-Item $zipPath -Force
             Write-Host "Temporary 7z file cleaned up"
           }
        shell: pwsh

      - name: Update Build Status to 'Success'
        if: success()
        run: |
          $body = @{
            build_id = "${{ steps.build_info.outputs.build_id }}";
            status = "success";
            artifact_url = "${{ steps.upload_artifact.outputs.artifact_url }}";
          } | ConvertTo-Json -Compress

          Invoke-RestMethod -Uri "${{ secrets.SUPABASE_URL }}/functions/v1/update-build-status" `
            -Method POST `
            -Headers @{
              "Authorization" = "Bearer ${{ secrets.GH_ACTION_SECRET }}";
              "Content-Type" = "application/json";
            } `
            -Body $body
        shell: pwsh

      - name: Update Build Status to 'Failed'
        if: failure() || cancelled()
        run: |
          $status = "failed"
          if ("${{ job.status }}" -eq "cancelled") {
            $status = "cancelled"
          }
          $body = @{
            build_id = "${{ steps.build_info.outputs.build_id }}";
            status = $status;
          } | ConvertTo-Json -Compress

          Invoke-RestMethod -Uri "${{ secrets.SUPABASE_URL }}/functions/v1/update-build-status" `
            -Method POST `
            -Headers @{
              "Authorization" = "Bearer ${{ secrets.GH_ACTION_SECRET }}";
              "Content-Type" = "application/json";
            } `
            -Body $body
        shell: pwsh
